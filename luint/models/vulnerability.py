"""
Vulnerability database models.
"""
import os
import json
import psycopg2
from psycopg2.extras import RealDictCursor
from typing import Dict, List, Any, Optional, Union

from luint.utils.logger import get_logger

logger = get_logger()


class VulnerabilityDatabase:
    """
    Vulnerability database manager.
    Provides access to vulnerability information stored in a PostgreSQL database.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the vulnerability database manager.
        
        Args:
            config (dict, optional): Configuration dictionary
        """
        self.config = config or {}
        self.db_path = self.config.get('vulnerability_db_path', 'data/vulnerabilities.json')
        self.db_conn = None
        self.db_initialized = False
        
        # Try to use PostgreSQL if DATABASE_URL environment variable is available
        self.use_postgres = bool(os.environ.get('DATABASE_URL'))
        
        if self.use_postgres:
            self._setup_postgres_connection()
        else:
            # Ensure directory exists for local JSON database
            os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
            
            # Initialize local database if it doesn't exist
            if not os.path.exists(self.db_path):
                self._initialize_local_database()
    
    def _setup_postgres_connection(self):
        """Set up the PostgreSQL database connection."""
        try:
            self.db_conn = psycopg2.connect(
                os.environ.get('DATABASE_URL'),
                cursor_factory=RealDictCursor
            )
            
            # Create tables if they don't exist
            with self.db_conn.cursor() as cursor:
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerability_categories (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255) UNIQUE NOT NULL
                    );
                """)
                
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerabilities (
                        id SERIAL PRIMARY KEY,
                        vuln_id VARCHAR(255) UNIQUE NOT NULL,
                        name VARCHAR(255) NOT NULL,
                        description TEXT,
                        severity VARCHAR(50) NOT NULL,
                        cvss FLOAT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );
                """)
                
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS vulnerability_references (
                        id SERIAL PRIMARY KEY,
                        vulnerability_id INTEGER REFERENCES vulnerabilities(id) ON DELETE CASCADE,
                        url TEXT NOT NULL,
                        UNIQUE(vulnerability_id, url)
                    );
                """)
                
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS technology_vulnerabilities (
                        id SERIAL PRIMARY KEY,
                        service VARCHAR(100),
                        product VARCHAR(100),
                        version VARCHAR(100),
                        vulnerability_id INTEGER REFERENCES vulnerabilities(id) ON DELETE CASCADE,
                        affected_range VARCHAR(255),
                        UNIQUE(service, product, version, vulnerability_id)
                    );
                """)
                
                self.db_conn.commit()
                self.db_initialized = True
                logger.info("PostgreSQL vulnerability database initialized")
                
                # Check if we need to populate with initial data
                cursor.execute("SELECT COUNT(*) as count FROM vulnerabilities")
                count = cursor.fetchone()['count']
                
                if count == 0:
                    self._populate_postgres_database()
        except Exception as e:
            logger.error(f"Error setting up PostgreSQL vulnerability database: {e}")
            self.use_postgres = False
    
    def _populate_postgres_database(self):
        """Populate the PostgreSQL database with initial vulnerability data."""
        try:
            # Sample vulnerability data to populate the database
            sample_data = self._get_sample_vulnerability_data()
            
            with self.db_conn.cursor() as cursor:
                for service, products in sample_data.items():
                    for product, versions in products.items():
                        for version, vulns in versions.items():
                            for vuln in vulns:
                                # Insert vulnerability
                                cursor.execute("""
                                    INSERT INTO vulnerabilities 
                                    (vuln_id, name, description, severity, cvss) 
                                    VALUES (%s, %s, %s, %s, %s)
                                    ON CONFLICT (vuln_id) DO UPDATE SET
                                    name = EXCLUDED.name,
                                    description = EXCLUDED.description,
                                    severity = EXCLUDED.severity,
                                    cvss = EXCLUDED.cvss
                                    RETURNING id
                                """, (
                                    vuln['id'],
                                    vuln['name'],
                                    vuln['description'],
                                    vuln['severity'],
                                    vuln.get('cvss', 5.0)
                                ))
                                
                                vuln_id = cursor.fetchone()['id']
                                
                                # Insert references
                                for ref in vuln.get('references', []):
                                    cursor.execute("""
                                        INSERT INTO vulnerability_references 
                                        (vulnerability_id, url) 
                                        VALUES (%s, %s)
                                        ON CONFLICT (vulnerability_id, url) DO NOTHING
                                    """, (vuln_id, ref))
                                
                                # Insert technology relationship
                                cursor.execute("""
                                    INSERT INTO technology_vulnerabilities 
                                    (service, product, version, vulnerability_id) 
                                    VALUES (%s, %s, %s, %s)
                                    ON CONFLICT (service, product, version, vulnerability_id) DO NOTHING
                                """, (service, product, version, vuln_id))
            
            self.db_conn.commit()
            logger.info("Populated PostgreSQL vulnerability database with initial data")
        except Exception as e:
            logger.error(f"Error populating PostgreSQL vulnerability database: {e}")
    
    def _initialize_local_database(self):
        """Initialize a local JSON database file with sample vulnerability data."""
        try:
            with open(self.db_path, 'w') as f:
                json.dump(self._get_sample_vulnerability_data(), f, indent=2)
            logger.info(f"Initialized local vulnerability database at {self.db_path}")
            self.db_initialized = True
        except Exception as e:
            logger.error(f"Error initializing local vulnerability database: {e}")
    
    def _get_sample_vulnerability_data(self) -> Dict[str, Any]:
        """
        Get sample vulnerability data for initializing the database.
        This provides a comprehensive starting dataset.
        
        Returns:
            dict: Sample vulnerability data
        """
        return {
            'http': {
                'Apache': {
                    '2.4.49': [
                        {
                            'id': 'CVE-2021-41773',
                            'name': 'Apache HTTP Server Path Traversal',
                            'description': 'A path traversal vulnerability in Apache HTTP Server 2.4.49 allows attackers to read arbitrary files on the server.',
                            'severity': 'critical',
                            'cvss': 9.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-41773',
                                'https://httpd.apache.org/security/vulnerabilities_24.html'
                            ]
                        },
                        {
                            'id': 'CVE-2021-42013',
                            'name': 'Apache HTTP Server Path Traversal (Follow-up)',
                            'description': 'The fix for CVE-2021-41773 in Apache HTTP Server 2.4.50 was insufficient, allowing for continued path traversal attacks.',
                            'severity': 'critical',
                            'cvss': 9.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42013',
                                'https://httpd.apache.org/security/vulnerabilities_24.html'
                            ]
                        }
                    ],
                    '2.4.50': [
                        {
                            'id': 'CVE-2021-42013',
                            'name': 'Apache HTTP Server Path Traversal (Follow-up)',
                            'description': 'The fix for CVE-2021-41773 in Apache HTTP Server 2.4.50 was insufficient, allowing for continued path traversal attacks.',
                            'severity': 'critical',
                            'cvss': 9.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-42013',
                                'https://httpd.apache.org/security/vulnerabilities_24.html'
                            ]
                        }
                    ]
                },
                'Nginx': {
                    '1.20.0': [
                        {
                            'id': 'CVE-2021-23017',
                            'name': 'Nginx Resolver Buffer Overflow',
                            'description': 'A buffer overflow vulnerability in the resolver component of Nginx may allow an attacker to cause a crash or potentially execute arbitrary code.',
                            'severity': 'high',
                            'cvss': 7.5,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23017',
                                'https://nginx.org/en/security_advisories.html'
                            ]
                        }
                    ]
                },
                'IIS': {
                    '10.0': [
                        {
                            'id': 'CVE-2021-31166',
                            'name': 'HTTP Protocol Stack Remote Code Execution',
                            'description': 'A remote code execution vulnerability exists in the HTTP Protocol Stack (http.sys) due to improper validation of input.',
                            'severity': 'critical',
                            'cvss': 9.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-31166',
                                'https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-31166'
                            ]
                        }
                    ]
                }
            },
            'ssh': {
                'OpenSSH': {
                    '8.3': [
                        {
                            'id': 'CVE-2020-15778',
                            'name': 'OpenSSH Allows Command Injection',
                            'description': 'OpenSSH through 8.3 allows command injection when a user connects to a server and specifies the command scp -t.',
                            'severity': 'medium',
                            'cvss': 6.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-15778'
                            ]
                        }
                    ]
                }
            },
            'dns': {
                'BIND': {
                    '9.11.20': [
                        {
                            'id': 'CVE-2020-8618',
                            'name': 'BIND Update Forwarding Denial of Service',
                            'description': 'A vulnerability in BIND allows an attacker to force a denial of service by exploiting a flaw in the update forwarding feature.',
                            'severity': 'high',
                            'cvss': 7.5,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8618',
                                'https://kb.isc.org/docs/cve-2020-8618'
                            ]
                        }
                    ]
                }
            },
            'cms': {
                'WordPress': {
                    '5.7.0': [
                        {
                            'id': 'WP-CVE-2021-24209',
                            'name': 'WordPress Object Injection',
                            'description': 'WordPress is vulnerable to object injection through the wp_phpmailer_init_smtp() function.',
                            'severity': 'medium',
                            'cvss': 6.5,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-24209',
                                'https://wordpress.org/news/2021/05/wordpress-5-7-2-security-release/'
                            ]
                        }
                    ],
                    '5.8.2': [
                        {
                            'id': 'WP-CVE-2022-21663',
                            'name': 'WordPress SQL Injection',
                            'description': 'A SQL injection vulnerability in WP_Query affects WordPress versions prior to 5.8.3.',
                            'severity': 'high',
                            'cvss': 8.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-21663',
                                'https://wordpress.org/news/2022/01/wordpress-5-8-3-security-release/'
                            ]
                        }
                    ]
                },
                'Drupal': {
                    '9.1.0': [
                        {
                            'id': 'CVE-2021-25967',
                            'name': 'Drupal Core Access Bypass',
                            'description': 'Some Drupal core subsystems do not properly check access for entities in certain contexts.',
                            'severity': 'medium',
                            'cvss': 6.1,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-25967',
                                'https://www.drupal.org/sa-core-2021-001'
                            ]
                        }
                    ]
                },
                'Joomla': {
                    '3.9.24': [
                        {
                            'id': 'CVE-2021-23132',
                            'name': 'Joomla Inadequate ACL Checks',
                            'description': 'Inadequate ACL checks in Joomla! allowing unauthorized access to certain actions',
                            'severity': 'medium',
                            'cvss': 5.4,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-23132',
                                'https://developer.joomla.org/security-centre'
                            ]
                        }
                    ]
                }
            },
            'database': {
                'MySQL': {
                    '8.0.25': [
                        {
                            'id': 'CVE-2021-2307',
                            'name': 'MySQL Server Information Disclosure',
                            'description': 'Vulnerability in MySQL Server allows unauthorized disclosure of sensitive information.',
                            'severity': 'medium',
                            'cvss': 5.5,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-2307',
                                'https://www.oracle.com/security-alerts/cpuapr2021.html'
                            ]
                        }
                    ]
                },
                'PostgreSQL': {
                    '13.2': [
                        {
                            'id': 'CVE-2021-3393',
                            'name': 'PostgreSQL Privilege Escalation',
                            'description': 'PostgreSQL before 13.3 allows privilege escalation via certain catalog views.',
                            'severity': 'high',
                            'cvss': 7.8,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-3393',
                                'https://www.postgresql.org/about/news/postgresql-133-127-1112-and-1017-released-2210/'
                            ]
                        }
                    ]
                }
            },
            'framework': {
                'Django': {
                    '3.1.7': [
                        {
                            'id': 'CVE-2021-28658',
                            'name': 'Django QuerySet Potential Memory Leak',
                            'description': 'A potential memory leak in Django QuerySet.explain() with specific parameters.',
                            'severity': 'medium',
                            'cvss': 5.0,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-28658',
                                'https://www.djangoproject.com/weblog/2021/mar/18/security-releases/'
                            ]
                        }
                    ]
                },
                'Flask': {
                    '1.1.2': [
                        {
                            'id': 'CVE-2021-26539',
                            'name': 'Flask Potential Format String Vulnerability',
                            'description': 'Format string vulnerability in Flask through 1.1.2 when using certain format strings.',
                            'severity': 'medium',
                            'cvss': 6.1,
                            'references': [
                                'https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-26539',
                                'https://github.com/pallets/flask/security/advisories/GHSA-562c-5r94-xh97'
                            ]
                        }
                    ]
                }
            }
        }
    
    def get_vulnerabilities(self, service: str, product: str, version: str) -> List[Dict[str, Any]]:
        """
        Get vulnerabilities for a specific service, product, and version.
        
        Args:
            service (str): Service name (e.g., http, ssh)
            product (str): Product name (e.g., Apache, OpenSSH)
            version (str): Version string
            
        Returns:
            list: List of vulnerability dictionaries
        """
        if not service or not product:
            return []
        
        # Normalize inputs to handle None values or empty strings
        service = service.lower() if service else ''
        product = product if product else ''
        version = version if version else ''
        
        vulnerabilities = []
        
        try:
            if self.use_postgres and self.db_conn:
                with self.db_conn.cursor() as cursor:
                    cursor.execute("""
                        SELECT v.*, array_agg(vr.url) as references
                        FROM vulnerabilities v
                        JOIN technology_vulnerabilities tv ON v.id = tv.vulnerability_id
                        LEFT JOIN vulnerability_references vr ON v.id = vr.vulnerability_id
                        WHERE 
                            LOWER(tv.service) = %s AND 
                            tv.product = %s AND 
                            (tv.version = %s OR %s LIKE tv.affected_range)
                        GROUP BY v.id
                    """, (service, product, version, version))
                    
                    for row in cursor.fetchall():
                        vuln = dict(row)
                        # Convert array to list
                        vuln['references'] = vuln['references'][0] if vuln['references'] and None not in vuln['references'] else []
                        vulnerabilities.append(vuln)
            else:
                # Use local JSON database
                try:
                    with open(self.db_path, 'r') as f:
                        db = json.load(f)
                        
                    service_vulns = db.get(service, {})
                    product_vulns = service_vulns.get(product, {})
                    
                    # Check exact version match
                    if version in product_vulns:
                        vulnerabilities.extend(product_vulns[version])
                    
                    # Additionally, check for version patterns (exact matches)
                    # A more sophisticated version would implement version range checking
                    for ver, vulns in product_vulns.items():
                        if ver != version and (ver in version or version in ver):
                            vulnerabilities.extend(vulns)
                except FileNotFoundError:
                    logger.error(f"Vulnerability database file not found: {self.db_path}")
                except json.JSONDecodeError:
                    logger.error(f"Invalid JSON in vulnerability database file: {self.db_path}")
        except Exception as e:
            logger.error(f"Error fetching vulnerabilities: {e}")
        
        return vulnerabilities
    
    def get_cve_details(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """
        Get details for a specific CVE ID.
        
        Args:
            cve_id (str): CVE ID or vulnerability identifier
            
        Returns:
            dict or None: Vulnerability details or None if not found
        """
        try:
            if self.use_postgres and self.db_conn:
                with self.db_conn.cursor() as cursor:
                    cursor.execute("""
                        SELECT v.*, array_agg(vr.url) as references
                        FROM vulnerabilities v
                        LEFT JOIN vulnerability_references vr ON v.id = vr.vulnerability_id
                        WHERE v.vuln_id = %s
                        GROUP BY v.id
                    """, (cve_id,))
                    
                    row = cursor.fetchone()
                    if row:
                        vuln = dict(row)
                        vuln['references'] = vuln['references'][0] if vuln['references'] and None not in vuln['references'] else []
                        return vuln
            else:
                # Use local JSON database
                try:
                    with open(self.db_path, 'r') as f:
                        db = json.load(f)
                    
                    # Search through all vulnerabilities to find matching CVE ID
                    for service_data in db.values():
                        for product_data in service_data.values():
                            for version_vulns in product_data.values():
                                for vuln in version_vulns:
                                    if vuln.get('id') == cve_id:
                                        return vuln
                except FileNotFoundError:
                    logger.error(f"Vulnerability database file not found: {self.db_path}")
                except json.JSONDecodeError:
                    logger.error(f"Invalid JSON in vulnerability database file: {self.db_path}")
        except Exception as e:
            logger.error(f"Error fetching CVE details: {e}")
        
        return None
    
    def search_vulnerabilities(self, query: str) -> List[Dict[str, Any]]:
        """
        Search for vulnerabilities by keyword.
        
        Args:
            query (str): Search keyword or phrase
            
        Returns:
            list: List of matching vulnerability dictionaries
        """
        results = []
        query = query.lower()
        
        try:
            if self.use_postgres and self.db_conn:
                with self.db_conn.cursor() as cursor:
                    cursor.execute("""
                        SELECT v.*, array_agg(vr.url) as references
                        FROM vulnerabilities v
                        LEFT JOIN vulnerability_references vr ON v.id = vr.vulnerability_id
                        WHERE 
                            LOWER(v.vuln_id) LIKE %s OR
                            LOWER(v.name) LIKE %s OR
                            LOWER(v.description) LIKE %s
                        GROUP BY v.id
                        LIMIT 50
                    """, (f'%{query}%', f'%{query}%', f'%{query}%'))
                    
                    for row in cursor.fetchall():
                        vuln = dict(row)
                        vuln['references'] = vuln['references'][0] if vuln['references'] and None not in vuln['references'] else []
                        results.append(vuln)
            else:
                # Use local JSON database
                try:
                    with open(self.db_path, 'r') as f:
                        db = json.load(f)
                    
                    # Search through all vulnerabilities
                    for service_data in db.values():
                        for product_data in service_data.values():
                            for version_vulns in product_data.values():
                                for vuln in version_vulns:
                                    if (query in vuln.get('id', '').lower() or
                                        query in vuln.get('name', '').lower() or
                                        query in vuln.get('description', '').lower()):
                                        results.append(vuln)
                except FileNotFoundError:
                    logger.error(f"Vulnerability database file not found: {self.db_path}")
                except json.JSONDecodeError:
                    logger.error(f"Invalid JSON in vulnerability database file: {self.db_path}")
        except Exception as e:
            logger.error(f"Error searching vulnerabilities: {e}")
        
        return results[:50]  # Limit results
    
    def close(self):
        """Close the database connection if using PostgreSQL."""
        if self.use_postgres and self.db_conn:
            self.db_conn.close()
            self.db_conn = None